using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ET_1_ChessBoard
{
    public class ProgramParams : IEquatable<ProgramParams>
    {
        #region Сonstants

        public const int MIN_COUNT_ARGS = 2;
        public const int MAX_COUNT_ARGS = 4;
        public const char STANDART_MAIN_SYMBOL = '#';
        public const char STANDART_SPACE_SYMBOL = ' ';

        #endregion

        public int Length { get; set; }
        public int Height { get; set; }
        public char WhiteCell { get; set; }
        public char BlackCell { get; set; }

        public static bool TryParse(string[] args, out ProgramParams programParams)
        {
            programParams = new ProgramParams();
            int length;
            int height;
            char main = STANDART_MAIN_SYMBOL;
            char space = STANDART_SPACE_SYMBOL;

            if (args.Length < MIN_COUNT_ARGS || args.Length > MAX_COUNT_ARGS)
            {
                return false;
            }
            if (!(Int32.TryParse(args[0], out length) && Int32.TryParse(args[1], out height)))
            {
                return false;
            }
            if (length < 0 || height < 0)
            {
                return false;
            }
            if ((args.Length > 2 && !Char.TryParse(args[2], out main)) ||
                (args.Length > 3 && !Char.TryParse(args[3], out space)))
            {
                return false;
            }

            programParams.Length = length;
            programParams.Height = height;
            programParams.WhiteCell = main;
            programParams.BlackCell = space;          

            return true;
        }

        public static string GetInstruction()
        {
            string message = "Parameter List: " + "\n"
                + "Length <Numeric> More than zero" + "\n"
                + "Height <Numeric> More than zero" + "\n"
                + "White cell <Symbol> Optional" + "\n"
                + "Black cell <Symbol> Optional" + "\n";
            return message;
        }

        public override bool Equals(object obj)
        {
            return this.Equals(obj as ProgramParams);
        }

        public bool Equals(ProgramParams p)
        {
            // If parameter is null, return false.
            if (Object.ReferenceEquals(p, null))
            {
                return false;
            }

            // Optimization for a common success case.
            if (Object.ReferenceEquals(this, p))
            {
                return true;
            }

            //Return true if the fields match.
            return (Length == p.Length) && (Height == p.Height) &&
                (WhiteCell == p.WhiteCell) && (BlackCell == p.BlackCell);
        }

        //Generated by VisualStudio
        public override int GetHashCode()
        {
            var hashCode = Length.GetHashCode();
            hashCode = hashCode * 11 + Height.GetHashCode();
            hashCode = hashCode * 22 + WhiteCell.GetHashCode();
            hashCode = hashCode * 33 + BlackCell.GetHashCode();
            return hashCode;
        }

        public static bool operator ==(ProgramParams leftP, ProgramParams rightP)
        {
            // Check for null on left side.
            if (Object.ReferenceEquals(leftP, null))
            {
                if (Object.ReferenceEquals(rightP, null))
                {
                    // null == null = true.
                    return true;
                }

                // Only the left side is null.
                return false;
            }
            // Equals handles case of null on right side.
            return leftP.Equals(rightP);
        }

        public static bool operator !=(ProgramParams leftP, ProgramParams rightP)
        {
            return !(leftP == rightP);
        }
    }
}
